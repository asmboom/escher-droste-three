<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="cleartype" content="on">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <script id="droste-vert" type="x-shader/x-vertex">

        #ifdef GL_ES
                #extension GL_OES_standard_derivatives : enable
                 precision mediump float;
        #endif

        /***
        // = object.matrixWorld
            uniform mat4 modelMatrix;

            // = camera.matrixWorldInverse * object.matrixWorld
            uniform mat4 modelViewMatrix;

            // = camera.projectionMatrix
            uniform mat4 projectionMatrix;

            // = camera.matrixWorldInverse
            uniform mat4 viewMatrix;

            // = inverse transpose of modelViewMatrix
            uniform mat3 normalMatrix;

            // = camera position in world space
            uniform vec3 cameraPosition; **/
           
        varying vec2 vUv;           
        varying vec3 vNormal, vViewPosition;

      
        void main() {

            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); //eyecoords

            vUv = uv;//texture position
           
            vNormal = normalize( normal * normalMatrix); //normal superfice
            vViewPosition = - mvPosition.xyz; 

            //transform the vertex from model space to clip coordinates
            gl_Position = projectionMatrix * mvPosition;

        }

    </script>

    <script  id="droste-frag" type="x-shader/x-fragment">


            #ifdef GL_ES
                #extension GL_OES_standard_derivatives : enable
                precision mediump float;
            #endif

            #define PI 3.14159265358979323846           
            #define PI2 6.2831853071
            
            /* three */
          
            varying vec2 vUv;    
            varying vec3 vNormal, vViewPosition;

                      /* lights */

            uniform float u_roughness;
            uniform float u_albedo;
            uniform float u_shinyness;
            uniform float u_fresnel;
            uniform float u_alpha;

            uniform vec3 ambientLightColor;

            #if MAX_POINT_LIGHTS > 0
                uniform vec3 pointLightColor[MAX_POINT_LIGHTS];
                uniform vec3 pointLightPosition[MAX_POINT_LIGHTS];
                uniform float pointLightDistance[MAX_POINT_LIGHTS];
                uniform float pointLightDecay[ MAX_POINT_LIGHTS ];
            #endif
        
            #if MAX_DIR_LIGHTS > 0
                uniform vec3 directionalLightColor[MAX_DIR_LIGHTS];
                uniform vec3 directionalLightDirection[MAX_DIR_LIGHTS]; 
            #endif 

            vec3 toLinear(in vec3 v, in float gamma){
                    return pow(abs(v), vec3(gamma));
            }

            vec3 toGamma(in vec3 v, in float gamma){               
                    return pow( abs(v), vec3(1.0/gamma));
              
            }

            float lightAttenuation( in float lightDistance, in float cutoffDistance, in float decayExponent ) {

                if ( decayExponent > 0.0 ) {
                  return pow( clamp( -lightDistance / cutoffDistance + 1.0, 0.0, 1.0 ), decayExponent );
                }
                return 1.0;
            }

            float orenNayarDiffuse(in vec3 lightDirection, in vec3 viewDirection, in vec3 surfaceNormal, in float roughness, in float albedo) {

                  float LdotV = dot(lightDirection, viewDirection);
                  float NdotL = dot(lightDirection, surfaceNormal);
                  float NdotV = dot(surfaceNormal, viewDirection);

                  float s = LdotV - NdotL * NdotV;
                  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));

                  float sigma2 = roughness * roughness;
                  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
                  float B = 0.45 * sigma2 / (sigma2 + 0.09);

                  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;
            }
                
            //https://gist.github.com/Kuranes/3065139b10f2d85074da

            #define saturate( v ) clamp( v, 0.0, 1.0)

            float G1V(in float dotNV, in float k){
                return 1.0/(dotNV*(1.0-k)+k);
            }

            float LightingFuncGGX_OPT1(in vec3 N, in vec3 V, in vec3 L, in float roughness, in float F0)
            {
                float alpha = roughness*roughness;

                vec3 H = normalize(V+L);

                float dotNL = saturate(dot(N,L));
                float dotLH = saturate(dot(L,H));
                float dotNH = saturate(dot(N,H));

                float F, D, vis;

                // D
                float alphaSqr = alpha*alpha;
       
                float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;
                D = alphaSqr/(PI * denom * denom);

                // F
                float dotLH5 = pow(1.0-dotLH,5.0);
                F = F0 + (1.0-F0)*(dotLH5);

                // V
                float k = alpha/2.0;
                vis = G1V(dotLH,k)*G1V(dotLH,k);

                float specular = dotNL * D * F * vis;
                return specular;
            }

            /* postfx */

            /* escher-droste */
            
            #define factor 256.0

            uniform sampler2D texture;
            uniform vec2 size;          
            uniform float time;
            uniform float p1,p2;
                
            vec2 cmul(in vec2 a, in vec2 b) {
                return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x );
            }
             
            vec2 clog(in vec2 v) {
                return vec2( 0.5 * log(v.x*v.x+v.y*v.y), atan(v.y,v.x) );
            }            

            /* MAIN */      

            void main() {

                vec2 pos = -1.0 + 2.0 * vUv;        
   
                /* escher-droste */
                    
                vec2 logpos = clog(pos);                  
                vec2 transformed = cmul( logpos, vec2(p2, -p1*log(factor)/PI2 ) );
                vec2 uv = vec2( -transformed.y/PI2, transformed.x/log(factor) - time *.2 );   
                vec3 materialColor =  toLinear( texture2D( texture, uv).rgb, 2.2);

                /* lights */
      
                float atten = 1.0;
                float diffuse = 1.0;

                vec3 specularColor = vec3(1.0, 1.0, 1.0);

                vec3 totalDiffuseLight = vec3( 0.0 );
                vec3 totalSpecularLight = vec3( 0.0 );              
                 
                #if MAX_POINT_LIGHTS > 0
                    for(int i = 0; i < MAX_POINT_LIGHTS; i++) {

                        vec3 L = normalize( pointLightPosition[i] + vViewPosition.xyz );
                        vec3 N =  vNormal;
                      
                        vec3 V = normalize(cameraPosition - vViewPosition );

                        vec3 H = normalize( V + L );

                        atten = lightAttenuation( length( L ), pointLightDistance[ i ], pointLightDecay[ i ] );

                        float spec = LightingFuncGGX_OPT1(N, V,  L, u_roughness, u_shinyness);
                       

                        float diffuse = orenNayarDiffuse( L, V, N, u_roughness, u_albedo);

                        totalDiffuseLight += diffuse * atten * pointLightColor[i] ;     
                        
                        totalSpecularLight += spec * specularColor *  pointLightColor[i] ;

                    }
                #endif
                      
                #if MAX_DIR_LIGHTS > 0
                    for(int i = 0; i < MAX_DIR_LIGHTS; i++) {

                        vec3 L = normalize( directionalLightDirection[i] );
                        vec3 N = vNormal; 
                        vec3 V = normalize( vViewPosition );
                        vec3 H = normalize( V + L );
                      
                        float NdotL = max( dot( N, L ), 0.0); 

                        float spec = LightingFuncGGX_OPT1(N, V,  L, u_roughness, u_shinyness);
                       
                        //float dirDotNormalHalf = max( dot( N, H), 0.0 );
                        //float dirSpecularWeight = 0.5 * max( pow( dirDotNormalHalf, 0.0 ), 0.0 );

                        float diffuse = orenNayarDiffuse( L, V, N, u_roughness, u_albedo);

                        totalDiffuseLight += diffuse * directionalLightColor[i];

                        totalSpecularLight += spec * NdotL * specularColor * directionalLightColor[i] ;
                    }
                #endif

                //diffuse ligths + gamma correction
                vec3 color = ambientLightColor + materialColor * totalDiffuseLight + totalSpecularLight;



                gl_FragColor = vec4( toGamma(color, 2.2), 1.0);
            }

       </script>

        <link rel="stylesheet" type="text/css" href="css/style.css">
   
     <script src="https://code.jquery.com/pep/0.4.1/pep.js"></script>
       <script src='js/head.min.js'></script>
     <script src='js/dat.gui.min.js'></script>
    <script src='js/Tween.js'></script>
    <script src='js/Detector.js'></script>
    <script src='js/raf.js'></script>
    <script src='js/rStats.js'></script>


    <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js'></script>
    <script src='js/three/controls/OrbitControls.js'></script>

    <script src='js/three/shaders/FilmShader.js'></script>
    <script src='js/three/shaders/CopyShader.js'></script>   
    <script src='js/three/postprocessing/EffectComposer.js'></script>
    <script src='js/three/postprocessing/ShaderPass.js'></script>
    <script src='js/three/postprocessing/MaskPass.js'></script> 
    <script src='js/three/postprocessing/RenderPass.js'></script>
</head>
<body>
    <div class="what">
        <h1>Escher-Drost GLSL Shader<br/>tech: ThreeJS r73 (PBR shading)</h1>
    </div>
    <div id="webgl-demo"></div>
    <script src='js/escher-droste--pbr.js'></script>
</body>
</html>