<!doctype html>
<html lang="en">
<head>

   <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  	<script id="vertexshader" type="x-shader/x-vertex">

  	 	#ifdef GL_ES
   	     	precision highp float;
        #endif
   
  	    varying vec2 vUv;
      	varying vec3 vPos;
    		varying vec3 vNormal;
    		varying vec3 vViewPosition;

    		void main() {

    		    vUv = uv;

    		    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    		 	  vPos = ( modelMatrix * vec4(position, 1.0 ) ).xyz;  

    		 	  vViewPosition = -mvPosition.xyz;

    		 	 //normal
    		    vNormal = normalMatrix * normal;
    		    
    		    gl_Position = projectionMatrix * mvPosition;
    		}

	</script>
	<!--<script  id="fragmentshader" type="x-shader/x-fragment">

	      #ifdef GL_ES
   	     	 	precision highp float;
        #endif

        /* three */

        #define pi 3.14159265358979323846
        #define factor 256.0
        #define pi2 6.2831853071
        
	   		varying vec2 vUv;
  			varying vec3 vPos;
  			varying vec3 vNormal;
  			varying vec3 vViewPosition;

  			#if MAX_DIR_LIGHTS > 0
  				  uniform vec3 directionalLightPosition[ MAX_DIR_LIGHTS ];
  			    uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];
  			    uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];
  			#endif

	   		/* escher-droste */
	
	   		uniform sampler2D map;
	   		//uniform sampler2D normalMap;

        uniform vec2 size;        	
        uniform float time;
        //uniform vec3 Falloff;  
        uniform float p1,p2;
               	
        vec2 cmul(vec2 a,vec2 b) {
            return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x );
  	    }
  	         
  	   vec2 clog(vec2 v) {
  	       return vec2( 0.5 * log(v.x*v.x+v.y*v.y), atan(v.y,v.x) );
  	   }	         

			void main() {

				/* escher-droste */

				vec2 position = -1.0 + 2.0 * vUv;			
        vec2 logpos = clog(position);                  
        vec2 transformed = cmul( logpos, vec2(p2, -p1*log(factor)/pi2 ) );
        vec2 uv = vec2( -transformed.y/pi2, transformed.x/log(factor)-time*.2);   
        vec3 color = texture2D( map, uv).rgb;		
				/* lights */

			 

    		/**#if MAX_DIR_LIGHTS > 0    

      				vec3 diffuseLight = vec3( 0.0 );
      				float lambert = 0.0;

      				for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {	    					
        					
                  //vec4 lightDir = normalize( viewMatrix * vec4( directionalLightDirection[ i ], 0.0 ) );

        					vec3 N = normalize( directionalLightPosition[i] - vViewPosition  );
        					vec3 L = normalize( directionalLightDirection[i] );
        					
        					// compute diffuse lighting
        					lambert = max( dot(N, L), 0.0);

        					if ( lambert > 0.0){

        						 diffuseLight += directionalLightColor[ i ] * lambert;
        						
        						//float D = length( L );
        						//calculate attenuation
        						//float attenuation = 1.0 / ( Falloff.x + (Falloff.y*D) + (Falloff.z*D*D) );
        					}				   		
      				} 

    			#endif*/

          //color *= diffuseLight.rgb ;

          gl_FragColor = vec4( color, 1.0);
			}

	   </script>-->
     <script  id="fragmentshader" type="x-shader/x-fragment">

          #ifdef GL_ES
            precision highp float;
          #endif

          #define pi 3.14159265358979323846
          #define factor 256.0
          #define pi2 6.2831853071
          
          #define RADIUS 0.5 //RADIUS of our vignette, where 0.5 results in a circle fitting the screen
          #define SOFTNESS 0.45//softness of our vignette, between 0.0 and 1.0

          /* three */

        varying vec2 vUv;
      varying vec3 vPos;
      varying vec3 vNormal;

      /* directional lights */

      uniform vec3 directionalLightColor[MAX_DIR_LIGHTS];
      uniform vec3 directionalLightPosition[MAX_DIR_LIGHTS];
      uniform float directionalLightDistance[MAX_DIR_LIGHTS];

        /* escher-droste */
  
        uniform sampler2D texture;
          uniform vec2 size;          
          uniform float time;
          uniform float p1,p2;
                
          vec2 cmul(vec2 a,vec2 b) {
              return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x );
          }
           
          vec2 clog(vec2 v) {
            return vec2( 0.5 * log(v.x*v.x+v.y*v.y), atan(v.y,v.x) );
          }          

      void main() {

        /* escher-droste */

        vec2 position = -1.0 + 2.0 * vUv;     
            vec2 logpos = clog(position);                  
            vec2 transformed = cmul( logpos, vec2(p2, -p1*log(factor)/pi2 ) );
            vec2 uv = vec2( -transformed.y/pi2, transformed.x/log(factor)-time*.2);   
            
        /* lights */

        vec4 lights = vec4(0.0, 0.0, 0.0, 1.0);
          for(int i = 0; i < MAX_DIR_LIGHTS; i++) {

            // normalizza vettore luce con 
            vec3 lightDir = normalize( directionalLightPosition[i] - vPos );

            //calcola contributo lambertiano
           float lambertian = max( dot(lightDir, vNormal), 0.0);
            //pointLights.rgb += clamp( dot(-lightDirection, vNormal), 0.0, 1.0) * pointLightColor[l];
           lights.rgb += lambertian * directionalLightColor[i];
        }

               
        //vec2 radius = vec2( .45, .45);
        float dist = length( uv );
        float vignette = smoothstep(.75, .75, dist);
            
            vec3 color = texture2D( texture, uv).rgb  + lights.rgb;
            
            //color.rgb = mix(color.rgb, color.rgb * vignette, 0.5);

                gl_FragColor = vec4( color, 1.0);
      }

     </script>

	   <link rel="stylesheet" media="screen" href="css/style.css" />    
</head>

<body>
	<div class="" id="canvas"></div>
	<script src="js/scripts.min.js"></script> 
  <script src="js/shaders/EscherDrosteShader.js"></script>    
   	<script src="js/escher-droste.js"></script>
</body>

</html>
